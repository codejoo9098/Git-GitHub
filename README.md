
# Git과 GitHub를 사용해서 Markdown.md 파일을 만들어보기

<https://github.com/codejoo9098/Git-GitHub>

<br>

# Git 설정하기 : config

먼저 git을 이용해서 markdown 문서를 만드려고 시작한다. 아직은 문서 편집을 시작하기도 전인 상태인 것이다. 즉 아직 markdown도, git도 어떤 것도 준비되지 않은 상태인 것이다. 우선 나는 git이 준비되지 않은 상태에서 git을 준비된 상태로 만들고 싶다. 그러기 위해서 사용하는 명령어가 바로 `git config` 명령어이다.

`git config`은 일종의 git에서의 `환경설정` 같은 것이다.환경설정을 해서 git을 준비된 상태로 만들기 위해 해야될 것은 config로 **사용자 이름** 이랑 **사용자 이메일**을 설정하는 것이다. 이름과 이메일을 설정하는 코드는 다음과 같다.

    git config --global user.name "주재완"
    git config --global user.email "yjjw2000@naver.com"

이 설정을 했으면 이제 git은 준비된 상태인 것이다. 이것을 설정함으로서 이제 git을 사용할 수 있게 되었다. 이 명령어는 처음 시작할때 한 번만 설정하면 된다. 이것을 한번 설정하면 나중에 git 프롬프트를 실행할때 다시 이렇게 설정하지 않아도 된다는 것이다.

정리를 하자면 위의 명령어 두 줄은 git을 설치하고 처음 시작할 때 git을 준비된 상태로 만들어주는 명령어이다. 처음 홈페이지를 이용할때 회원가입을 하는 것처럼 이 명령어도 **회원가입**의 의미로 볼 수 있을 것 같다.

하지만 상황에 따라서 사용자의 이름이나 이메일을 변경해야 할 상황이 올 수도 있다. 이 역시 `git config`의 옵션으로 해결할 수 있다. `git config`의 옵션으로 이미 지정된 사용자 이름이나 이메일을 초기화 할 수 있다. 그 명령어는 다음과 같다.

    git config --unset --global user.name
    git config --unset --global user.email

이렇게 되면 기존에 지정되 있던 사용자 이름과 이메일 주소가 삭제가 된다. 즉 이 명령어는 기존에 저장된 사용자 이름 또는 이메일 주소를 삭제하는 명령어라고 볼 수 있다. 기존 데이터가 삭제가 되었으니 다시 git을 사용하려면 앞서 언급한 명령어를 이용해서 사용자 이름과 이메일을 새로 설정해야한다.

또한 현재 내 이름과 이메일 주소를 조회하고 싶을 수 있다. 그럴때는 다음과 같은 명령어를 입력하면 된다.

    git config --list

이것을 입력했을시 다음과 같은 창이 출력되는것을 확인할 수 있다.

![config_1](https://user-images.githubusercontent.com/76525173/116966471-39168000-aceb-11eb-8b4a-9d0d50fdc3b7.jpg)

여기서 확인해야 할 것은 맨 밑의 두 줄이다. 맨 밑의 두 줄에 `user.name`과 `user.email`이 있는데, 이 두 줄이 각각 내가 설정한 이름과 이메일 주소를 나타낸다. 이것을 통해 이름과 이메일 주소를 확인할 수 있다.

또한 이와는 별개로 `git config --list`를 입력하면 `git config`와 관련된 여러 상태들을 출력하는것을 볼 수 있다. 이것을 통해 `git config --list`는 현재 환경설정에서 설정된 상태들을 출력하는 명령어라는것을 알 수 있다.

# git 시작하기 : init

`git config`를 이용해서 git을 준비된 상태로 만들었고, 이제 본격적으로 내가 만드려는 markdown 파일을 git이 관리하도록 만들고 싶다. 즉 현재 상황은 git과 markdown이 준비된 상태고, 이 markdown문서가 git이 관리하고 있는 상태가 아니다. 그래서 이 markdown 문서를 git이 관리하는 상태로 만드려고 한다. 그러기 위해서 사용하는 명령어가 `git init` 이다.

`git init`은 해당 디렉토리를 git이 관리하는 상태로 만들어주는 명령어이다. 이 명령어를 사용하면 해당 디렉토리에 있는 모든 파일들은 git 관리 하에 있게 되며, 소스 코드 공유, 이전 버전으로 되돌리기 등 git이 가지는 장점들을 이용해서 이 파일들을 관리할 수 있게 된다.

먼저 처음에는 git이 관리하고자 하는 디렉토리를 설정해야한다. 그 명령어는 다음과 같다.

    cd 경로명

이것을 입력하면 프롬프트가 보고있는 경로가 변경이 된다. 그리고 다음과 같은 명령어를 입력하면 git이 시작된다.

     git init

그리고 다음과 같은 화면이 뜨면 정상이다.

![init_1](https://user-images.githubusercontent.com/76525173/116967766-091cac00-acee-11eb-922e-425fc2acc4c9.jpg)

이제 이렇게 되면 해당 경로에 있는 파일들은 모두 git 관리 하에 있게 되는 것이다. 사진에 예시 같은 경우에는 C:\Users\JaeWan\Desktop\Markdown_git\markdown 경로에 있는 파일들이 git 관리 하에 있게 된 것이다.

정리하자면 `git init` 명령어는 파일들을 git으로 관리하기 위해서 해당 파일이 있는 디렉토리를 git 관리 하에 있도록 설정하는 명령어라고 볼 수 있다. 즉 파일을 git으로 관리하기 위한 출발점으로 볼 수 있다.

# 본격적으로 Git을 시작하기 전에

Git을 시작하기 전에 먼저 Git이 어떻게 돌아가는지 알아야 한다. 우선 Git이 지정된 디렉토리는 다음 3가지의 작업 공간을 가진다. 여기 작업공간들을 포함하는 공간을 `local directory`라고 한다. 이 부분에 대해서는 Github로 넘어갈때 다시 설명하겠다.

- Working directory
  - untracked
  - tracked
- Staging area
- .Git directory

### Working directory

현재 작업중인 파일들이 담겨있는 공간이다. 대부분 수정이 이루어지고 있는 파일들이 들어있으며, Git이 추적중이지 않은 `untracked`와 추적 중인 `tracked`로 나뉜다. `tracked` 파일은 다시 `Unmodified`와 `Modified` 상태로 나뉜다. 파일을 처음 생성하면 대부분 파일들은 `untracked` 된 상태로 이 작업 공간에 담기게 되며, 별도의 명령어를 입력하지 않으면 계속 `untracked`로 남게 된다. 이따 언급하겠지만 `git add`를 이용해서 `staging area`로 보낼 수 있으며, `staging area` 또는 `.git directory`로 부터 수정이 되면 다시 이 작업 공간으로 올 수 있다.

### Staging area

`git add`를 통해서 `working directory`로부터 올라온 파일들을 보관하고 있는 장소이다. 기본적으로 git이 추적하고 있는것을 전제하고 있으며, snapshot이 되기 전 상태인, snapshop이 될 준비가 될 파일들이 모인 공간이라고 보면 된다. 이따 언급하겠지만, `git commit`를 통해서 `.git directory`로 보낼 수 있고, 수정이 필요하다면 수정을 해서 다시 `working directory`로 보낼 수 있다.

### .Git directory

`git config`를 통해서 `staging area`로부터 올라온 파일들을 보관하고 있는 장소이다. snapshot이 되어 있는 파일들이 여기 들어있으며, snapshot이 됬다는 것은 git이 파일의 그 순간을 저장했다는 의미로 받아들이면 될 것 같다. 저장이 됬으니 필요할 때 언제든지 이 snapshot된 파일로 되돌아갈수 있는 상태인 것이다. 수정 등의 과정을 통해서 파일을 다시 `working directory`나 `staging area`로 보낼 수 있다. 하지만 파일을 보내더라도 snapshot된 것은 그대로 남아있으므로 언제든지 다시 원래 파일로 접근할 수 있다.

# Staging area로 보내기 : git add

`git init`을 통해서 디렉토리를 git이 관리하는 상태로 만들었다. 그리고 나는 markdown 파일 초안을 완료한 상태다. 현재 git이 관리하고 있는 디렉토리에는 Markdown.md 파일만 있는 상태이다. 아직 별도로 디렉토리에 명령을 하지 않은 상태여서, 현재 markdown 파일은 `working directory`에 `untracked`된 상태로 있다. 이 상태에서 나는 이 파일을 `staging area`로 올리고 싶다. 그렇게 해서 현재 일부 작성된 이 markdown 파일을 snapshot 되기 전 상태로 만들고 싶다. 이때 이용하는 명령어가 `git add` 이다.

`git add`을 사용하려면 대상 파일을 지정해야 한다. 올리고자 하는 파일을 콕 집어서 지정할 수 있다. 다음과 같이 말이다.

    git add Markdown.md

이렇게 되면 Markdown.md 파일을 콕 집어서 이 파일만 `staging area` 영역으로 올릴 수 있다. 파일 하나가 아니라 모든 파일을 올리고 싶다면 다음과 같은 명령어를 사용하면 된다.

    git add -A

이것을 이용하면 `git init`을 통해 지정된 디렉토리 내에 모든 파일들이 staging area로 올라가게 된다.

앞서 언급한 명령어들을 입력해서 md 파일이 `staging area`로 올라갔다. 이 상태에 있는 파일은 수정을 하면 다시 `untracked`된 상태로 `working directory`로 내려오게 된다. 이 일련의 과정들을 확인하는 방법이 있다. 그것은 밑에 `git status`를 설명할때 언급하겠다.

정리하자면 `git add`는 `working directory`에 있는 파일들을 `tracked` 됬든 안됬든, `staging area`로 올려주는 역할을 한다. 또한 `add` 뒤에 어떤 옵션을 넣냐에 따라서 특정 파일만 지정해서 올릴 수 있고, 디렉토리 내 모든 파일들을 올릴 수 있다. 학생 입장에서는 `-A` 옵션을 아마 많이 사용할 것이다.

# 파일의 현재 상태 확인하기 : status

현재 `git add`를 이용해서 md파일을 `staging area`에 올린 상태이다. 이전에도 언급했지만 현재 디렉토리에는 Markdonw.md 파일만 존재한다. 나는 이것이 정상적으로 `staging area`에 올라갔는지 확인하고 싶다. 그것을 확인하기 위해서 `git status` 명령어를 사용할 수 있다.

`git status`는 다른 옵션 없이 단순이 아래 명령어만 입력하면 현재 파일 상황을 확인할 수 있다.

    git status

내가 만든 파일이 정상적으로 `staging area`에 올라갔다면 다음과 같이 화면을 출력할 것이다.

![status_1](https://user-images.githubusercontent.com/76525173/116973249-3588f600-acf7-11eb-9c0e-0aefda7fa100.jpg)

Changes to be committed: 밑에 초록색 글씨로 되어있는 파일명은 정상적으로 올라갔다는 뜻이다.

만일 정상적으로 올라가지 않았더라면 다음과 같이 출력할 것이다.

![status_2](https://user-images.githubusercontent.com/76525173/116973262-3a4daa00-acf7-11eb-9a3f-dfab25cfafd0.jpg)

Untracked files: 밑에 빨간색 글씨로 되어있는 파일명은 아직 `Working directory`에 `untracked` 된 상태로 남아있다는 뜻이다.

`staging area`에 올린 상태에서 수정을 하고 수정된 파일을 저장할 수 있다. 그럴 경우에는 다음과 같은 화면을 출력하게 된다.

![status_3](https://user-images.githubusercontent.com/76525173/116973281-40438b00-acf7-11eb-9b44-2878473952bb.jpg)

초록색 글씨로 된 파일명과 빨간색 글씨로 된 파일명이 둘다 존재한다는 것을 알 수 있다. 초록색 글씨로 된 것은 수정을 하지 않은 파일이 그대로 `staging area`에 남아있는 것이고, 빨간색 글씨로 된 것은 수정된 파일이 `Modified` 된 상태로 `working directory`에 남아있는 것이다. 이 상태는 하나의 파일이 두 개로 나뉘어져, 수정되지 않은 파일(원본)은 `commit`되기를 기다린 채 `staging area`에 있는 것이고, 수정된 파일은 `working directory`에 있는 것이다. 이 파일들을 다루는 법은 이따 `git commit`를 서술할 때 설명하겠다.

정리하자면 `git status` 명령어는 어떤 파일이 `staging area`에 있는지, 어떤 파일이 `working directory`에 있는지, 또 `working directory`안에는 어떤 파일이 `tracked` 되있고 어떤 파일이 `untracked` 되있는지 한눈에 확인할 수 있는 명령어이다. 추가로 `.git directory`에 있는 파일들은 이 명령어를 통해서 확인할 수 없다. 아마 학생이라면 별도의 옵션 없이 `git status`만을 통해서 필요한 정보들을 모두 확인할 수 있을 것이다.

# .Git directory로 올리기 : git commit

현재 나는 초안을 작성했고, 이 초안은 현재 `staging area`에 있는 상태이다. 초안인 만큼 여러 방면으로 변경될수가 있고, 변경하다 보면 다시 초안으로 돌아갈 수 있기 때문에 나는 이 초안을 snapshot해서 언제든지 다시 돌아갈 수 있도록 저장해두고 싶다. 다시 말해, snapshot을 통해서 이 md파일을 `.git directory`로 올리고 싶다. 그러기 위해서는 `git commit` 명령어를 사용하면 된다.

`git commit`를 이용해서 현재 진행된 상황을 snapshot을 찍어서 `.git directory`에 저장할 수 있다. `-m` 명령어와 커밋 시 같이 저장할 내용을 이용해서 커밋할 수 있다. 다음과 같이 말이다.

    git commit -m "First Commit!"

여기서 "First Commit!"은 커밋할 때 함께 저장되는 내용이다. 현재 커밋에 관련된 내용을 서술하면 나중에 커밋 사항들을 확인하기 용이할 것이다.

이 명령어를 사용해서 정상적으로 커밋이 됬다면, 즉 정상적으로 `.git directory`에 snapshot이 됬다면, 다음과 같은 화면을 출력할 것이다.

![commit_1](https://user-images.githubusercontent.com/76525173/117125921-1bbde080-add5-11eb-9b8c-d2b2c9d451ae.jpg)

이런 화면이 뜨면 정상적으로 `.git directory`에 올라간 것이다. 이제부터 `.git directory`에 `git commit`을 이용해서 snapshot을 올린 것을 `커밋한다.` 라고 표현하겠다. 그리고 `staging area`에 있던 파일을 커밋했으니, 이제 `staging area`에는 아무것도 없다. 그래서 `git status`를 입력하면 아무것도 뜨지 않을 것이다. 다음과 같이 말이다.

![status_aftercommit](https://user-images.githubusercontent.com/76525173/117126307-8c64fd00-add5-11eb-88ea-4142c0e21152.jpg)

다음과 같은 화면이 떴을 때, 초록 글씨든 빨간 글씨든 `staging area`에 남아있는 파일이 없으면 이 영역의 파일이 정상적으로 상위 영역으로 올라갔다고 보면 된다. 물론 `.git directory`로 올라갔는지 더 확실하게 확인하는 방법이 있다. 그것은 이따 `git log`를 설명할때 자세하게 설명하겠다.

문서를 작성하고 나서 `git add`를 한 다음 `git commit` 이렇게 두 단계로 나뉘어서 커밋을 하는것이 귀찮을수도 있다. 그래서 위에서 언급한 commit 명령어에 `-a` 명령어를 추가해서 `working directory`에 있는 파일을 한번에 `.git directory`에 올릴 수 있다. 다음과 같이 입력하면 된다.

    git commit -a -m "First Commit!"

기존에 `git add`를 안 한 상태에서, 즉 `git init`외에 어떤 명령어도 입력하지 않은 상태에서 위의 명령어를 입력하면 snapshot하고자 하는 파일을 한번에 `.git directory`로 올릴 수 있다. 학생 입장에서는 앞서 언급한 두 가지의 명령어를 자주 사용할 것 같다.

정리하자면 `git commit` 명령어는 `staging area` 또는 `working directory`에 있는 파일들을 snapshot 해서 `.git directory`에 올리는 명령어임을 알 수 있다. 그 파일을 올리는 과정에서 일부 설명을 추가해서 (ex : First Commit!) 각각 커밋한 내용들을 더욱 잘 구분하도록 할 수 있다.

# 커밋 로그 확인하기 : git log

현재 초안을 완성을 했고 그 파일을 커밋까지 한 상태이다. 나는 이 md파일이 정상적으로 커밋이 됬는지 확인하고 싶다. 이를 위해서 나는 `git log`를 사용할 수 있다.

`git log`는 그동한 커밋한 내역들을 화면에 쭉 출력해주는 명령어이다. 특별한 옵션 없이 다음과 같이 입력해도된다.

    git log

이것을 입력하면 그동안 내가 커밋한 내용들을 화면에 쭉 출력한다. 다음과 같이 말이다.

![log_1](https://user-images.githubusercontent.com/76525173/117127665-558fe680-add7-11eb-9594-74241f0fdfa6.jpg)

현재 커밋을 한 번 했으니 하나의 로그 내역을 출력할 것이다. 로그 내역 하나당 본인이 처음에 설정한 본인 정보와 커밋한 시간, 커밋할때 남긴 메세지와 branch 정보를 나타낸다. branch에 대해서는 추후에 설명할 것이다.

단순히 `git log`를 하면 이름, 시간 등 너무 많은 정보를 출력한다고 생각할 수 있다. 그에 반해서, 이런 정보들을 줄이고 로그 하나를 한 줄로 간단하게 표현하는 명령어도 있다. 그 명령어는 다음과 같다.

    git log --oneline --graph --decorate --all

이 명령어는 로그 하나하나를 간단하게 표현하고 로그들이 연결되있는 상황을 그림처럼 표현해준다. 현재는 커밋을 한 번만 한 상태여서 이것이 얼마나 좋은 명령어인지 와닿지 않겠지만, 나중에 branch 등을 설명할때, 이 명령어는 아주 유용하게 쓰는 명령어가 될 것이다. 아마 학생이라면 `git log`와 위의 명령어를 자주 사용할 것 같다.

정리를 하자면 `git log`는 내가 커밋한 내용들을 출력하는 명령어이다. 문서를 작성하고 수정하다 보면 커밋을 한 번만 하는 것이 아니라 여러번 할텐데, 그 때 이 명령어를 이용하면 커밋 내용들을 모두 확인할 수 있다. 또한 reset등을 이용해서 내가 commit한 내용에 특별한 조치를 취하고 싶을 때, 이 명령어를 우선적으로 사용할 것이다. 즉 단순히 커밋 내용만 확인하는것에서 끝나는 것이 아니라 커밋한 내용들에 손을 대고 싶을때도 이 `git log`를 사용할 것이다.

# 파일을 이전 상태로 되돌리기 : git reset --hard

나는 초안을 작성하고 커밋을 했고, 그 초안을 동료들에게 평가를 받았다. 동료들은 130~150 라인의 내용들을 수정하기를 권했다. 그래서 그 라인의 내용을 수정하고 다시 커밋을 했다. 그리고 동료들에게 다시 평가를 받았다. 그런데 이게 무슨 일이람, 동료들은 내가 처음에 작성한 내용 즉 처음에 커밋한 내용이 더 괜찮다면서, 다시 그 내용으로 작성하자고 한다. 살짝 화가 나지만 나는 처음 커밋한 내용으로 문서를 되돌려놓고자 한다.

git 명령어로 표현을 하자면 이렇다. 130~150 라인을 수정을 했고, `git commit -a -m "Second Commit!` 명령어를 이용해서 커밋을 했고, `git log`를 이용해서 현재 작성된 파일이 두 번째 커밋안에 담겨있다는것을 확인했다. 다음과 같이 말이다.

![reset_1](https://user-images.githubusercontent.com/76525173/117130151-9d643d00-adda-11eb-984d-38ced2bb2efa.jpg)

이 상태에서 나는 첫 번째 커밋한 상태("First commit")으로 돌아가고 싶은 것이다. 이를 위해서는 `git reset --hard`를 사용할 수 있다.

우선 이 명령어에 대해 이해하기 전에 먼저 위 사진 _Second Commit!_ 커밋에 달려있는 `(HEAD -> master)` 에 대해서 알아야 한다.
`HEAD`는 현재 가리키고 있는 커밋을 뜻한다. 작업을 하다 보면 여러번의 커밋을 할 것이고 각각의 커밋은 각기 다른 내용들을 snapshot한 상태로 담고 있을 것이다. 그 중 어떤 커밋 하나에 저 `HEAD`가 달려있을 것이다. 그 어떤 커밋 하나는 맨 위의 커밋, 가장 최근에 작성한 커밋일 것이다. `HEAD`가 달려있는 커밋은 **현재 상태의 커밋**이라고 보면 된다.

예를 들어서 첫 번째 커밋은 'A'라는 상태의 파일을 담고 있고, 두 번째 커밋은 'B'라는 상태의 파일을 담고 있다고 해보자. 그리고 `HEAD`는 두 번째 커밋을 가리키고 있다고 하자. 그러면 지금 사용자가 보고 있는 파일은 'B'상태의 파일일 것이다.

또한 `->master`이란 내용도 궁금할수도 있을 것이다. 이 내용에 관해서는 branch에서 자세히 설명하겠다.

즉 현재 파일 상황은 두 번째 커밋인 상황이고, 두 번째 커밋에 `HEAD`가 달려있다. 첫 번째 커밋인 상태로 파일을 만들고 싶으므로 첫 번째 커밋에 `HEAD`를 옮기고 싶은 것이다. 그것을 가능하게 하는 명령어가 `git reset --hard`이다. 이 명령어는 다음과 같이 쓰면 된다.

    git reset --hard 38a2157133a

`--hard` 뒤에 38a2157133a는 커밋의 식별번호 같은 것이다. 각 커밋들을 확인해 보면 노란색 글씨로 이런 형태의 식별번호들이 길게 늘어져 있는것을 볼 수 있다. 그 중 일부를 `--hard`뒤에 붙이면 된다. 몇 자를 붙여야 된다 이런것은 없고 적당히 붙이면 된다.

이 명령어를 사용하면 아래 사진과 같은 내용을 출력하고 `git log`를 입력해서 커밋 내용을 확인해보면 두 번째 커밋은 없어져있고 첫 번째 커밋만 `HEAD`가 달려있는채로 있는 것을 알 수 있다.

![reset_2](https://user-images.githubusercontent.com/76525173/117130159-a2c18780-adda-11eb-80ee-1bad4b13974f.jpg)

파일을 확인해 보았을때, 내가 처음에 커밋한 상태로 파일이 되돌아간것을 확인할 수 있다. 즉 파일을 처음 커밋한 상태로 되돌린 것이다.

하지만 `--hard`옵션에는 단점이 있다. 한 번 `--hard`를 이용해서 이전 커밋으로 `HEAD`를 옮겨버리면 다시 이 명령어를 사용하기 이전으로 돌아갈 수 없다는 것이다. 즉 지금 상황에서는 두 번째 커밋한 상태로 돌아갈 수 없다. 이 명령어를 사용할 때는 신중하게 사용해야 한다.

정리하자면 `git reset --hard`는 특정 커밋의 상태로 파일을 되돌리는 명령어라고 할 수 있다. 정확히 말하면 `HEAD`를 특정 커밋으로 옮겨서 현재 파일 상태를 그 커밋일때의 파일 상태로 만드는 것이라고 볼 수 있다.

# 또 다른 작업 환경 만들기 : branch, checkout

동료들에게 1차 평가를 받고 2차로 평가를 받아야 하는 상황이 왔다. 수정할 부분이 보여서 파일을 수정하고 있다. 수정을 하던 도중 2가지 수정본을 만들어보고 싶다는 생각이 들었다. 그래서 동료들에게 평가를 받을 때, 수정본 두 가지를 모두 가지고 있어서 한 번에 두 가지를 비교하면서 보여주고자 한다. 현재 상황은 결과적으로는 첫 번째 커밋한 상태에 머무르고 있는 상황이고, 이 파일을 두 가지 종류로 나누어서 수정하고 커밋하고 싶은 것이다. 그럴때 이용하는 명령어가 `git branch`랑 `git checkout`이다.

branch라는 것은 새로운 경로라고 보면 된다. 글로는 이해하기 힘드니 그림으로 설명하는 것이 좋을 것 같다.

    1 ----- 2 ----- 3

branch를 모르는 상태에서는 다음과 같이 커밋을 진행해왔다. 각 숫자는 커밋을 뜻한다. 1,2,3 번 형태가 다음과 같이 직렬로 연결되 있다. branch를 알면 다음과 같이 커밋을 할 수 있다.

    1 ------- 2
        ↘--- 3

1번 커밋에서 2, 3번 커밋을 위의 예시처럼 병렬로 연결할 수 있다. 즉 1번 커밋에서 2번 커밋으로도 갈 수 있고, 3번 커밋으로도 갈 수 있다. 2, 3번 커밋은 독립적으로 움직여서 2번 커밋이 없어진다 해도 3번 커밋에 영향을 끼치는 것이 아니고, 3번 커밋이 없어진다 하더라도 2번 커밋에 영향을 끼치지 않는다.

branch도 이와 비슷하다. 원래 경로에서 벗어나 새로운 경로를 만드는 것이고, 그곳에 커밋을 만드는 것이다. 그리고 원래 경로, 처음 `git init`할때 있는 경로를 `master`라고 한다. 새로 만들어진 경로에 있는 커밋은 특별한 명령어를 쓰지 않으면 원래 경로에 있는 커밋과는 별개로 움직인다.

우선 새로운 경로를 만들어보려고 한다. 그때 쓰는 명령어가 `git branch`다. 다음과 같은 명령어를 이용해서 경로명이 'my-idea'인 branch를 만드려고 한다.

    git branch my-idea

`git branch` 다음에 만들고자 하는 branch명(경로명)을 적으면 그 이름을 가진 새로운 branch가 만들어진다. 다음과 같이 입력하면 정상적으로 새로운 branch가 만들어졌을 것이다. 현재 존재하는 branch들을 확인하는 방법은 다음과 같은 명령어를 입력하면 된다.

    git branch

그러면 경로들이 뜰 것이다. 현재 branch를 하나만 만들었으니 이 명령어를 입력하면 branch가 2개가 뜰 것이다. 그리고 현재 있는 경로 앞에 `*`가 붙어있을 것이다. 이 과정은 아래 사진과 같이 나타날 것이다.

![branch_1](https://user-images.githubusercontent.com/76525173/117136350-38f9ab80-ade3-11eb-83d7-f2e7a90a2714.jpg)

그리고 경로명 옆에 `(master)`라고 되어있을 것이다. 이것이 현재 branch를 뜻한다. 현재는 master branch, 즉 `init`할 때 처음 생성된 branch에 있는 것이다.

또한 존재하는 branch들을 확인하면서 동시에 현재 어떤 커밋을 가리키고 있는지 알고싶을수 있다. 그럴때는 다음과 같은 명령어를 입력하면 된다.

    git branch -v

이것을 입력하면 다음과 같이 화면이 출력된다.

![branch_v](https://user-images.githubusercontent.com/76525173/117158206-2d65af00-adfa-11eb-9a00-249156600b96.jpg)

존재하는 브랜치만 출력하는것이 아니라 브랜치명 옆에 커밋명 역시 출력하는것을 알 수 있다.

master에 커밋을 하고 branch를 변경하고 싶을 것이다. 그럴 때 이용하는게 `checkout` 명령어이다. 이 명령어는 다음과 같이 이용하면 된다.

    git checkout my-idea

`checkout` 뒤에 이동하고자 하는 branch를 적으면 해당 branch로 이동한다. 위의 명령어를 입력하면 my-idea인 branch로 이동할 것이다. 그리고 다음과 같은 화면을 출력할 것이다.

![checkout_1](https://user-images.githubusercontent.com/76525173/117136296-27b09f00-ade3-11eb-9e67-4b5269f9b5ab.jpg)

정상적으로 branch가 변경되었다는 메세지와 함께 밑에 경로명 옆이 `(my-idea)`로 변경되었다는것을 알 수 있다. 이는 현재 branch가 새로 만든 my-idea로 변경된 것이다.

현재 branch인 my-idea에 내가 생각하고 있는 첫 번째 케이스로 수정을 한 뒤 커밋을 하고, 다시 master 브랜치로 돌아와서 두 번째 케이스로 수정을 한다. 그 일련의 과정은 다음과 같다.

![modify_commit](https://user-images.githubusercontent.com/76525173/117137419-a0642b00-ade4-11eb-9f2d-5bf2b09d9597.jpg)

브랜치가 my-idea가 되어있는 상태에서 문서를 편집하고 커밋을 한뒤, master 브랜치로 `checkout`을 한 뒤 거기서 다시 수정을 하고 커밋을 했다. 위 사진은 이 과정을 나타내고 있다.

그리고 이 상황을 한 눈에 보고 싶다. `git log`를 이용해서 볼 수 있다. 하지만 단순히 `git log`만 하면 현재 브랜치의 로그 상황만 보여준다. 다음과 같이 말이다.

![log_master](https://user-images.githubusercontent.com/76525173/117137840-44e66d00-ade5-11eb-9a82-aed9fe6dbd23.jpg)

master 브랜치로 이동한 뒤 `git log`를 입력한 모습니다. my-idea의 커밋 상황은 보여주지 않고 master의 커밋 상황만 보여주고 있다. `(HEAD -> master)` 에서 `-> master`은 지금 HEAD가 가리키고 있는 커밋이 master 브랜치에 있다는것을 뜻한다. 현재는 master 브랜치인 상태니 이는 당연한 것이다. 만일 my-idea 브랜치로 이동했다면 위의 커밋은 `(HEAD -> my-idea)` 일 것이다.

이렇게 하면 여러 브랜치들을 한 눈에 볼 수 없다. 일부 정보들이 누락되어도 여러 브랜치들을 한 눈에 볼 수 있는 명령어가 필요하다. 그것이 위에서 언급한 명령어이다. 다음과 같다.

    git log --oneline --graph --decorate --all

이 명령어를 입력하면 어떤 브랜치에 있든지 관계없이 브랜치들의 상황을 한 눈에 보여준다. 다음과 같이 말이다.

![log_decorate_branch](https://user-images.githubusercontent.com/76525173/117137674-018bfe80-ade5-11eb-9da4-46ff2fd6c7a9.jpg)

이것을 보고 첫 번째 커밋(First commit) 이후 2개의 브랜치가 성공적으로 나뉘어졌고, 각각의 브랜치에서 각각의 커밋이 성공적으로 이루어졌다는것을 알 수 있다. `checkout`을 이용해서 master, my-idea 브랜치로 자유롭게 이동할 수 있으며, 각 브랜치로 이동할때마다 각 브랜치에서 수정하고 커밋한 내용으로 파일이 바뀌는것을 확인할 수 있을 것이다.

그리고 branch를 만들고 `checkout`을 한번에 하고 싶을 수 있다. 그럴때 이용하는 명령어가 다음과 같다.

    git checkout -b 브랜치명

다음과 같이 입력하면 해당 입력한 브랜치를 만듦과 동시에 해당 브랜치로 이동(체크아웃)한다.

`branch`와 `checkout` 내용을 정리하면 다음과 같다. `branch` 는 새로운 경로, 즉 새로운 branch를 생성해서 커밋을 직렬이 아닌 병렬로 할 수 있게 만드는 명령어이다. `branch`명령어를 이용해서 여러 가지의 결과물을 만들 수 있다. 학생으로서 자주 쓸 만한 명령어는 `git branch`, `git branch 브랜치명`(브랜치 생성) 과 `git branch -v`이다. 또한 `checkout`은 여러 브랜치들간을 이동시켜주는 명령어이다. 한 브랜치에서 커밋을 끝내고 다른 브랜치고 이동하고자 할 때 이 `checkout` 명령어를 쓰면 된다. 학생으로서 자주 사용할 명령어는 `checkout 브랜치명`이랑 `checkout -b 브랜치명`이 있다.

# 병합하기 : merge

동료들에게 두 가지의 수정본을 모두 보여주었다. 동료들은 이 두 가지 수정본에 있는 내용들이 모두 괜찮다면서 두 수정본을 합치라고 제안한다. master 브랜치의 수정본과 my-idea 브랜치의 수정본을 합치는 것을 제안하는 것이다. 그래서 나는 이 두 브랜치의 내용들을 병합하려고 한다. 그래서 이 두 브랜치에 내용들을 합쳐서 새로운 커밋을 만드려고 한다. 그럴 때 이용하는 명령어가 `git merge` 이다.

`git merge`는 어떤 브랜치에서 다른 브랜치의 내용을 불러와서 합치는 것이다. 병합 당하는 브랜치에 기존 브랜치에 없던 파일이 존재하는 경우에는 그 파일을 기존 브랜치에 새로 추가하는 것이고, 똑같은 파일의 경우 기존 브랜치와 한줄한줄 비교해가면서 내용을 추가하는 것이다. 기존 브랜치 A라는 파일에 'a' 라는 내용이 있고 병합 당하는 브랜치 A라는 파일에 'b'라는 내용이 있으면, 병합 시 기존 브랜치 A라는 파일에 'b'라는 내용이 합쳐져서 'ab'라는 내용의 파일이 되는 것이다. 이 상황에서는 다음과 같이 이용하면 된다.

    git checkout master
    git merge my-idea

우선 병합을 해서 합치고자 하는 브랜치를 정한다.(꼭 master 브랜치일 필요는 없다.) 그 브랜치로 먼저 `checkout`을 해야한다. 그 명령어가 다음과 같다.

    git checkout master

체크아웃을 한 이후에 병합하고자 하는 브랜치를 정하고 병합을 해야 한다. 그 명령어가 다음과 같다.

    git merge my-idea

이렇게 하면 master 브랜치에 my-idea 브랜치가 가리키고 있는 커밋의 내용이 합쳐질 것이다. 하지만 단순히 이렇게 하면 아마 다음과 같은 일이 일어날 것이다.

![merge_1](https://user-images.githubusercontent.com/76525173/117311119-e097dc00-aebe-11eb-9aa8-c29297a19710.jpg)

이렇게 창이 뜰 것이고, 문서로 가면 이런 일이 일어나있을 것이다.

![merge_confilct](https://user-images.githubusercontent.com/76525173/117311144-e68dbd00-aebe-11eb-8ab1-6929ae147aa3.jpg)

`merge`를 했을때, 아름답게 합쳐지면 좋겠지만 그렇지 않은 경우가 대부분일 것이다. 병합을 할 때 앞서 한 라인 한 라인 비교를 해 가면서 검사를 한다고 했다. 이 때 같은 문서, 같은 라인에 다른 내용이 있을 경우에는 git은 merge를 하지 않고 위의 사진처럼 사용자에게 안내한다. "똑같은 내용이 있어서 병합을 할 수 없습니다. 어떻게든 해결하고 오세요."를 보여주면서. 이런 상황을 conflict가 일어났다고 표현한다.

conflict가 났을 때는 이를 해결해야 한다. 가장 좋은 방법으로는 저 conflict가 난 부분을 적당하게 수정하는 것이다. 저 부분을 적당하게 수정한 다음에 `git commit -a -m "Merge!"` 명령어를 입력해서 다시 add를 하고 커밋을 하면 병합이 다시 일어난다. 아래 사진은 그 과정을 담고있다.

![merge_conflict_avoid](https://user-images.githubusercontent.com/76525173/117311234-fad1ba00-aebe-11eb-9d6e-843408c515d0.jpg)

우선 충돌이 난 부분을 다음과 같이 수정했다.

![merge_complete](https://user-images.githubusercontent.com/76525173/117311283-07eea900-aebf-11eb-98c6-a988c4077bbd.jpg)

그리고 add를 한 후 commit를 해서 merge를 완료했다.

또한 위의 사진을 보면 `--decorate`를 이용해서 로그를 출력한 부분도 보일 것이다. 정상적으로 merge가 되었다면 저런 decorate 모양을 출력할 것이다. 이는 병합을 하면 원래 2개로 나뉘어졌던 브랜치가 다시 하나로 합쳐진다는 것을 알려준다. 브랜치 모양이 병령에서 직렬로 바뀌는 것이다. 이 때 기준이 되는 브랜치를 master라고 해서 my-idea에 있는 브랜치는 그대로 있고 master 브랜치가 새로운 커밋을 만들어서 그것을 my-idea 브랜치가 가리키고 있는 커밋과 이어주는 것을 알 수 있다.

만일 충돌이 일어나지 않으면 별도의 수정 과정 없이 바로 add와 commit이 바로 일어나서 merge 명령 하나만으로 위의 decorate 모양이 만들어질 것이다.

정리를 하자면 merge는 기준이 되는 브랜치에 대상이 되는 브랜치를 불러와서 둘을 병합하는 것이다. 이 때 대상이 되는 브랜치에는 특별한 일은 일어나지 않는다. 병합을 성공하면 여러 개로 나뉘어져 있던 브랜치를 하나로 이어주는 커밋을 새로 만들고 기준이 되는 브랜치는 그 커밋을 가리키게 된다. 또한 병합에 실패했을때, 반드시 해결을 해야하는것은 아니다. 다음과 같은 명령어를 이용하면 병합을 없던 것으로 만들수 있다.

    git merge --abort

이 명령어를 이용하면 git은 merge를 없었던 일로 만들어준다. 즉 병합을 완전히 취소하는 것이다. 학생 입장에서는 `git merge 브랜치명`과 함께 `git merge --abort`를 많이 쓸 것 같다.

# 베이스를 다시 설정하자 : rebase

동료들에게 merge한 것을 평가를 받았다. 동료들은 반응이 좋다. 이제는 교수님께 갈 차례이다. 교수님은 md파일을 천천히 읽어보시더니 특정 부분의 내용이 계속 반복된다는것을 지적하셨다. 그래서 그 특정 내용을 맨 앞에 추가할 것을 제안했다. md파일을 수정하면서 나는 이번에도 두 가지의 수정본이 떠올랐고, 예전에 했던 것처럼 브랜치를 두 개를 나뉘어서(master, my-idea) 각각의 브랜치에 다른 수정본들을 커밋했다. 두 개의 수정본을 나누기 이전에, merge를 하고 나서는 my-idea 브랜치가 병합된 브랜치를 가리키고 있지 않은데, reset --hard 명령어를 이용해서 병합된 브랜치를 가리키도록 했다. 각각의 브랜치에 다른 내용들을 커밋한 뒤 교수님께 두 내용을 다시 보여드렸다. 그에 대한 결과물을 decorate로 표현하면 다음과 같다.

![rebase_decorate_1](https://user-images.githubusercontent.com/76525173/117311407-205ec380-aebf-11eb-88dd-e198574966a4.jpg)

교수님은 두 내용을 비교하더니 두 내용이 모두 있었으면 좋겠다는 얘기를 했다. 나는 그래서 이 두 내용을 다시 합치려고한다. 예전에 `merge`를 했던 것처럼, 하지만 `merge`를 했을때는 브랜치가 쓸데없이 2개로 나뉘어졌다는것을 알게 되었다. 이전에도 브랜치가 2개로 나뉘어졌다가 하나로 합쳐졌는데, 굳이 그렇게 할 필요는 없을 것 같다. 직렬로 한 경로로 쭉 이어지게 합치고 싶다. 정리하자면 두 커밋 내용을 병합을 하고 싶다. 하지만 `merge`를 했을때처럼 브랜치를 두 개로 나뉜 흔적을 남기지 않고 한 경로로 쭉 이어진 브랜치가 남도록 병합을 하고 싶다는 것이다. 이 때 쓸 수 있는 명령어가 `git rebase`이다.

`git rebase`는 말 그대로 re + base, 베이스(base)를 다시 설정한다는 것이다. 대상이 되는 브랜치를 원하는 브랜치에 갖다 놓음으로써 여러 갈래로 나뉘어진 브랜치를 하나의 경로로 만들수 있다. 여기서는 대상이 되는 브랜치를 my-idea라고 하고 기준 브랜치를 master 브랜치로 할 것이다. 즉 my-idea 브랜치를 master 브랜치로 가져다 놓을 것이다. 사용법은 다음과 같다.

    git checkout my-idea

먼저 기준이 되는 브랜치로 체크아웃을 해야한다. 그리고 다음과 같이 명령어를 입력한다.

    git rebase master

이 명령어는 master 브랜치로 베이스를 다시 정한다는 것이다. 즉 현재 있는 브랜치가 my-idea인데, 이 브랜치를 master 브랜치로 가져다 놓겠다는 것이다. 하지만 다음과 같이 입력하면 여전히 다음과 같은 일이 발생할 것이다.

![rebase_conflict_1](https://user-images.githubusercontent.com/76525173/117311444-2785d180-aebf-11eb-8171-f9574128e2a7.jpg)

프롬프트 창에 충돌이 발생했다는 알림이 뜰 것이고 md파일에 돌아가면 아까 merge했던 것과 비슷한 일이 발생했을 것이다. 다음과 같이 말이다.

![rebase_conflict_2](https://user-images.githubusercontent.com/76525173/117311531-39677480-aebf-11eb-9da7-bdcfe43990f6.jpg)

`merge`했을때처럼 역시나 충돌이 발생했다. 하지만 이러한 충돌은 해결할 수 있다. `merge`에서 해결했던 것처럼 파일을 변경해준다. 다음과 같이 말이다.

![rebase_modify](https://user-images.githubusercontent.com/76525173/117311562-41271900-aebf-11eb-9554-e2e16bfb56b4.jpg)

그리고 다음과 같은 명령어를 이용해서 다시 병합을 재개했다. rebase같은 경우에는 충돌이 난 부분을 수정한 후 `git add`를 한 다음 `git rebase --continue`를 해야한다. 그렇게 되면 다음과 같은 창이 뜰것이다. 그러면 성공한 것이다.

    [detached HEAD 6a3553c] before rebase_my-idea
    1 file changed, 1 insertion(+), 1 deletion(-)
    Successfully rebased and updated refs/heads/my-idea.

그리고 decorate를 이용해서 확인해보면 다음과 같이 되어있을 것이다.

![aftermerge](https://user-images.githubusercontent.com/76525173/117311602-4be1ae00-aebf-11eb-9fec-7d7c3494ebed.jpg)

성공적으로 병합이 되고 브랜치도 직렬로 되어있는것을 확인할수 있다. 하지만 여기서 거슬리는것이 있다. master 브랜치가 병합된 커밋을 가리키고 있지 않은 것이다. 이 브랜치를 병합된 커밋을 가리키게 하고 싶다. 이를 위해서 다음과 같은 명령어를 사용할 수 있다.

    git checkout master
    git rebase my-idea

이렇게 하고 decorate 명령어를 입력하면 다음과 같이 출력한다.

![rebase_final](https://user-images.githubusercontent.com/76525173/117314130-6cab0300-aec1-11eb-8161-639210bffa94.jpg)

이제 master 브랜치도 병합된 커밋을 가리키고 있다. master 브랜치로 체크아웃을 하고 my-idea로 rebase를 해서 master 브랜치를 my-idea 브랜치가 가리키고 있는 커밋으로 갖다놓은 것이다. 즉 master 브랜치의 base를 my-idea로 재배치(rebase) 한 것이다. 그런데 my-idea는 최신 커밋(병합된 커밋)을 가리키고 있으므로, master 브랜치 역시 최신 브랜치를 가리키고 있는것이다.

병합이 된 것은 `merge`와 똑같다. 하지만 `merge`와 다른 점은 브랜치를 병렬로 생성하지 않고, my-idea브랜치를 master 브랜치 쪽으로 갖다 놓았다는 것이다. master가 가리키고 있는 8923ae 커밋과 병합을 하고 병합한 커밋을 master 브랜치가 있는 경로에 놔두었다는 것이다.

만약 my-idea 경로에 여러 개의 커밋이 있다면 이렇게 된다. my-idea 경로에 있는 커밋들을 시스템은 따로 떼어놓는다. my-idea의 경로에 3개의 커밋이 있다면 시스템은 그 3개의 커밋을 따로 떼어놓는다. 그리고 그것을 master 브랜치에 그대로 갖다붙인다. 이 때 붙인 커밋들은 master 브랜치가 가리키고 있는 커밋과 하나하나 병합을 하면서 붙인다.

예를 들어 보자. master 브랜치가 가리키고 있는 커밋을 A1이라고 하고, my-idea 경로상에 있는 커밋들을 차례로 B1, B2, B3라고 하자. rebase를 하게 되면 B1-B2-B3 이렇게 이어져있는 커밋들을 A1에 그대로 붙인다. 그래서 A1-B1-B2-B3 이렇게 커밋이 이어지게 만든다. 이 때 B1, B2, B3 커밋들에 병합이 일어나게 된다. B1은 A1과 병합하고, B2는 이전에 B1과 A1을 병합한 커밋과 다시 병합하고, B3는 다시 이전에 병합된 커밋과 다시 병합을 하는 것이다. 즉 병합은 총 3번 일어나는 것이다.

만일 병합하는 도중 충돌이 일어나면 시스템은 경고 메세지를 띄우며 병합을 멈춘다. 이 때 앞서 언급한것처럼 충돌을 해결하고 다시 병합을 재개하던가, 아니면 --abort 옵션을 이용해서 병합을 없던일로 만들어야 한다.

`merge`는 각각의 두 브랜치가 가지고 있는 커밋들을 병합하는 것이다. 단순히 커밋 두개만 병합하는 것이다.
하지만 `rebase`는 단순히 커밋 2개를 병합하는 것이 아니라, 특정 브랜치의 경로에 있는 커밋들을 다른 브랜치로 가져다놓고, 커밋들을 병합을 해 나가는 것이다. 가장 많이 쓰는것은 당연히 `git rebase 브랜치명`이며, `merge`와 마찬가지로 `git rebase --abort`도 많이 쓸 것이도, 동시에 `git rebase --continue`역시 많이 쓸 것이다.

# 원격 저장소에 나의 파일을 올려보자

교수님께도 피드백을 받았다. 이제 모두 피드백을 받았고 과제를 제출하는 일만 남았다. 과제를 제출하는 방법은 github 원격 저장소에 나의 과제물을 올리고 나의 저장소 링크를 공유하는 형식이다. 이 과정에서 사용되는 명령어들을 소개하기 전에 마저 소개할 개념이 있다.

## local repository

이전에 .git repository를 언급한 적이 있었을 것이다. 이 .git repository와 어떻게 비슷하다고 볼 수 있다. 둘 다 snapshot을 한 파일들을 저장하는 저장소니까. 차이점은 다음과 같다. .git repository는 내 컴퓨터 안에 내장되어 있는 저장소이다. 즉 나만 볼 수 있다. remote repositry는 인터넷에 있는 원격 저장소이다. 즉 여기에 snapshot한 파일을 저장하면 해당 저장소에 접근할 수 있는 모든 사람들이 이 파일을 열람할 수 있다. 그리고 이 remote repository의 대표적인 예시가 바로 'Github' 이다. 이제부터 이 remote repository, Github를 다루는 방법 위주로 문서를 서술할 것이다.

# 원격 저장소를 추가하자 : remote

우선 원격 저장소에 파일을 올리기 위해서는 원격 저장소를 등록해야 한다. 그 명령어가 바로 remote 명령어이다. 이 명령어를 이용하면 내가 올리고자 하는 원격 저장소를 등록해서 지금 그리고 추후에 필요할 때 등록된 링크를 이용해서 원격 저장소에 파일을 올릴 수 있다. 즉 이 명령어를 이용해서 원격 저장소를 git 프롬프트에서 언제든지 이용할 수 있는 환경을 만들고자 한다. 우선 원격 저장소 링크부터 알아야 한다. 먼저 github 홈페이지에 들어가서 repository를 만든다. repository를 만들었으면, 그 repository에 들어간다. 그리고 초록색 버튼으로 된 "code"를 클릭한다. 그러면 repository의 주소를 확인할 수 있다. 다음 사진을 보면 쉽게 이해할 수 있을 것이다.

![remote_1](https://user-images.githubusercontent.com/76525173/117405126-0d430680-af46-11eb-8038-5953d71fffc0.jpg)

이제 등록하고자 하는 링크를 알았다. 그러면 이제 이 링크를 등록해야 한다. 등록을 하는 명령어는 다음과 같다.

    git reomte add origin 링크

`add`는 원격 저장소를 추가하는 명령어이다. 그리고 origin은 이 원격 저장소를 가리키는 이름이다. 보통 origin이라고 많이 쓴다. 다른 좋은 이름이 있으면 그것을 써도 된다. 등록된 원격 저장소를 확인하고 싶을 것이다. 그러면 다음과 같은 명령어를 입력하면 된다.

    git remote -v

다음과 같은 화면이 뜨면 정상적으로 등록된 것이다.

![remote_2](https://user-images.githubusercontent.com/76525173/117405482-aa9e3a80-af46-11eb-892c-97a1a258b5c5.jpg)

원격 저장소 이름이 뜨고 그 옆에 원격 저장소 링크가 뜨면 성공적으로 등록이 된 것이다. 똑같은 이름이 2개가 있어서 당황할수도 있다. fetch와 push는 한 쌍으로 가므로 이렇게 똑같은 이름에 fetch와 push가 뜨면 정상적으로 등록된 것이다.

만일 위의 명령어에서 `-v` 옵션을 빼고 `git remote`만 입력하면 링크는 빼고 저장소 이름만 출력한다.

또한 어떤 원격 저장소는 필요가 없어질수도 있다. 그럴 때는 `git remote -rm 저장소 이름`을 이용해서 필요없는 저장소를 제거할 수 있다. 정리하자면 `git remote`는 원격 저장소를 관리하는 명령어라고 볼 수 있다. `git init`이 git을 사용할 수 있는 환경을 만드는 명령어인 것처럼, `git remote`는 githyb를 사용할 수 있는 환경을 만드는 명령어라고 볼 수 있다. 또한 저장소를 추가, 수정, 삭제 등을 통해서 저장소들을 관리할 수 있다. 자주 사용하는 명령어는 `git remote add origin 저장소 이름`과 `git remote -v` 정도가 될 것 같다.

# 내가 만든 파일을 github에 올려보자 : push

repository 등록도 했겠다. 이제 내 파일을 본격적으로 제출하고자 한다. 내가 지금까지 커밋했던 내용들을 모두 원격 저장소로 제출해서 과제의 최종본과 지금까지의 수정본을 모두 확인할 수 있도록 할 예정이다. 이 때 이용하는 명령어가 `git push`이다.

`git push`는 지금까지 나의 저장소(로컬 저장소)에 저장되어있는 커밋들의 내역을 원격 저장소로 올리는 명령어이다. 다음과 같이 사용하면 된다.

    git push origin master

이 명령어의 의미는 다음과 같다. origin은 등록된 저장소의 이름이다. 이전에 원격 저장소를 등록했고, 그것의 이름을 origin 이라고 했다. 즉 origin을 입력하면 origin에 등록된 저장소로 커밋들을 올리겠다는 것이다. master는 올리고자 하는 브랜치이다. master 브랜치를 올리고 싶으면 master를, my-idea 브랜치를 올리고자 하면 my-idea를 입력하면 된다. 다음과 같이 입력하면 이런 창이 뜰 것이다.

![push_1](https://user-images.githubusercontent.com/76525173/117407298-52b50300-af49-11eb-922b-ac699eaf3c48.jpg)

처음에는 Username과 password를 입력하는 창이 뜰 것이다. 이 때는 각각 github의 아이디(이메일 주소)와 비밀번호를 입력하면 된다.

입력하고 나서는 위의 창이 뜰 것이다. 성공적으로 push가 된 것이다. 그리고 github 홈페이지에 들어가서 정상적으로 push가 됬는지 확인해보자.

![push_2](https://user-images.githubusercontent.com/76525173/117407755-f8687200-af49-11eb-8877-65f0ef5956fc.jpg)

우선 원격 저장소 홈페이지에 들어가보자. 홈페이지에 들어갔을 때, branches가 1개 더 추가되었다는것을 알 수 있다. 이것을 클릭해보자.

![push_3](https://user-images.githubusercontent.com/76525173/117407812-0d450580-af4a-11eb-9559-6093c78b2943.jpg)

여길 들어가보면 내가 올린 master 브랜치가 있다는것을 확인할 수 있다. 이 master 브랜치로 들어가면 `commit`이라고 되어있는 버튼을 확인할 수 있다. 그것을 클릭하면 지금까지 내가 커밋했던 내역들이 정상적으로 올라왔다는것을 알 수 있다. 다음과 같이 말이다.

![push_4](https://user-images.githubusercontent.com/76525173/117407826-1209b980-af4a-11eb-8669-5a15c8cf241c.jpg)

이로서 master 브랜치가 정상적으로 원격 저장소에 업로드 되었다는것을 확인할 수 있다. 또한 나는 더 많은 정보들을 남기고 싶다. my-idea에 저장된 커밋들도 원격 저장소에 남기고 싶다. 그럴때는 아까와 마찬가지로 다음과 같이 입력하면 된다.

    git push origin my-idea

이렇게 입력하면 my-idea 브랜치도 똑같이 master 브랜치처럼 push가 되었다는 것을 확인할 수 있다.

정리하자면 `git push` 명령어는 브랜치에 있는 커밋들을 원격 저장소로 전달하는 아주 기본적인 업로드 명령어이다. 원격 저장소에 파일을 저장하고자 할 때는 이 명령어를 이용하면 된다. 또한 브랜치가 여려개일때, 브랜치들을 하나하나 다 입력하는것은 번거로울 수 있다. 이 때 `git push origin --all`, 즉 `--all` 옵션을 붙여서 모든 브랜치들을 push할 수 있다. 학생 입장에서는 `git push`와 여기에 --all 을 붙인 명령어를 자주 사용할 것 같다.

# 원격 저장소에서 로컬 저장소로 파일 불러오기 : pull

파일을 수정하고 커밋을 하는 것은 내 컴퓨터에 저장되어있는 VSC를 통해서도 할 수 있다. 그런데 일단 원격 저장소로 파일을 push하면, 원격 저장소에서도 파일을 수정하고 커밋을 할 수 있다. 또한 접근 범위를 어떻게 지정하냐에 따라서 나 뿐만 아니라 이 repository에 접근할 수 있는 모든 사람들이 내 파일을 수정하고 커밋을 할 수 있다. 현재 나는 push를 통해서 과제를 원격 저장소에 제출한 상태이다. 그리고 과제 데드라인이 지났고, 교수님이 채점을 해주셨다. 교수님이 채점을 하고 피드백을 맨 밑에 추가해서 커밋을 했다. 즉 교수님에 의해서 원격 저장소에 커밋이 하나 더 추가된 것이다. 하지만 커밋을 원격 저장소에 했기에, 현재 나의 로컬 저장소에는 교수님의 피드백한 내용의 커밋이 없는 상태이다. 나는 이 커밋을 나의 로컬 저장소에도 남기고 싶다. 즉 현재 교수님에 의해서 원격 저장소에 커밋이 추가가 된 상태고 그로인해서 브랜치에도 변화가 일어난 상태이다. 나는 이 변화가 일어난 브랜치를 나의 로컬 저장소에 저장하고 싶다. 그럴 때 이용하는 명령어가 pull이다.

우선 설명하기 전에 원격저장소를 먼저 살펴보자. 원격저장소 사이트에 들어갔을때, 다음과 같은 커밋이 남겨져 있는것을 확인할 수 있다. 이 커밋이 교수님이 남긴 커밋이고, 나는 이 커밋을 로컬 저장소로 pull하고자 한다.

![pull_1](https://user-images.githubusercontent.com/76525173/117448605-e8688680-af79-11eb-8011-5ed6c71e7150.jpg)

pull 명령어는 원격 저장소에 있는 커밋들을 현재 내 로컬 저장소로 불러오는 명령어이다. 중요한 것은 커밋을 불러와서 기존의 커밋과 `merge`를 한다는 것이다. 위의 예시같은 경우에는 "Feedback_byProfessor" 커밋을 불러와서 master가 가리키고 있는 커밋 "before rebase_my-idea"과 `merge`를 하고 나서 커밋을 추가한다. 사용법은 다음과 같다. `merge`를 하는 것이다 보니까 conflict가 안일어나도록 미리 수정을 해야할 것이다.

    git pull origin master

여기서 origin은 불러오고자 하는 원격 저장소 이름이다. 앞서 원격 저장소 이름을 origin으로 했으니 origin이라고 입력한다. 그리고 master은 원격 저장소에서 가져와서 로컬 저장소에 배치하고자 하는 브랜치 명이다. master라고 했으니 master 브랜치에 저장을 할 것이다. 이렇게 입력하면 다음과 같은 화면이 뜰 것이다.

![pull_2](https://user-images.githubusercontent.com/76525173/117449386-e226da00-af7a-11eb-84ee-589513e641fc.jpg)

이렇게 비슷하게 뜨면 성공한 것이다. 더 확실히 알기 위해서 --decorate를 이용해서 그래프로 확인해보자

![pull_3](https://user-images.githubusercontent.com/76525173/117450219-e7d0ef80-af7b-11eb-8212-18aad2910b20.jpg)

성공적으로 pull이 되었다는 것을 알 수 있다. 위 사진에서 origin/브랜치명은 원격 저장소에 있었던 브랜치를 뜻한다. 원격 저장소에 브랜치가 master랑 my-idea가 있었는데, my-idea 브랜치는 push 이후 별다른 수정을 거치지 않았기 때문에 기존 로컬 저장소에 브랜치와 똑같아서 기존 my-idea가 가리키고 있던 커밋에 똑같이 간 것을 확인할 수 있다. pull의 대상을 master 브랜치로 정했기 때문에 pull을 했을 때 새로운 커밋이 기존 master 브랜치가 가리키고 있던 커밋과 `merge`를 하고 추가되었다는것을 알 수 있다. 그래서 로컬 저장소의 master 브랜치와 원격 저장소의 master 브랜치가 똑같은 커밋을 가리키고 있는 것이다.

정리하자면 pull 명령어는 원격 저장소 내에 있는 모든 커밋 내용들을 로컬 저장소로 불러오는 명령어라고 할 수 있다. 불러오는 과정에서 변화가 생긴 커밋이 있다면 병합을 하고 추가를 한다는 것 역시 알 수 있다. 병합을 하는 과정에서는 충돌이 있을 수 있기 때문에 나의 로컬 저장소와 비교를 잘 해서 충돌이 일어나지 않도록 해야한다. 학생 입장에서 자주 쓸 만한 명령어는 앞서 언급한 명령어 정도라고 생각한다.

# 다른 폴더, 다른 기기에서도 원격 저장소 내용들을 불러오자 : clone

교수님의 피드백이 담긴 파일까지 나의 저장소로 불러오는것을 성공했다. 나는 내가 만든 제출물에 충분히 뿌듯함을 느낀다. 이 과제물은 단순히 과제로만 끝나는 것이 아니라 수시로 커밋을 하고 싶다. 그런데 단순히 폴더 하나에만 의존하기에는 위험하다는 생각이 들었다. 커밋을 하다가 안 좋은 일이 발생했을 때 쓸 수 있는 또 다른 폴더, 즉 예비 폴더를 만들고 그 폴더에 지금 내가 작업하고 있는 내용들을 똑같이 복사하고 싶다. 정리하자면 새로운 폴더를 만들어서 그 폴더를 지금 내가 작업하고 있는 환경이랑 똑같이 만들고 싶다는 것이다. 이때 쓰는 명령어가 `git clone`이다.

`git clone` 명령어는 빈 폴더(`git init`도 안된 폴더)에 원격 저장소 내용을 가져오는 명령어이다. 사용법은 다음과 같다.

    cd 대상 경로
    git clone URL

여기서 URL은 나의 원격 저장소 링크를 뜻한다. 빈 폴더를 만들고 cd 명령어를 이용해서 그 경로로 이동한 다음 `clone` 명령어를 입력하면 다음과 같은 창이 뜰 것이다.

![clone_1](https://user-images.githubusercontent.com/76525173/117456441-26b67380-af83-11eb-8aff-26c3e7dd67b0.jpg)

복사가 정상적으로 되었다면 cd를 이용해서 정한 경로 안에 새로운 폴더 하나가 더 만들어졌을 것이다. 다시 cd를 통해서 그곳으로 이동하면 `git init`이 되고 원격 저장소로부터 커밋 내역들을 받은 흔적이 있는 git 저장소라는것을 확인할 수 있을 것이다. 원격 저장소로부터 내용을 받아서 브랜치마다 origin이 달려있다. 여기서 origin은 원격 저장소를 나타내는 이름이라고 생각하면 된다. 그런데 그냥 `git branch`를 입력하면 main 브랜치만 뜰 것이다. 다음과 같은 명령어를 입력해야지 모든 브랜치들을 확인할 수 있다.

    git branch -a

그렇게 되면 위의 사진에서 보이는 것처럼 빨간색 글씨로 브랜치명들을 출력할 것이다. 저 빨간색 글씨들로 되어있는 브랜치들은 **로컬 브랜치**가 아닌 **임시 브랜치**라고 할 수 있다. 임시 브랜치들을 사용하는것은 꽤나 불편하다. 이것들을 모두 로컬 브랜치로 바꿔줘야 한다. 그것을 바꾸는 명령어는 다음과 같다.

    git checkout --track origin/master

이 명령어는 origin/master라는 임시 브랜치를 로컬 브랜치로 바꿔주면서(이름을 그대로 유지하면서) 해당 브랜치로 체크하웃 하는 명령어이다. 같은 방법으로 my-idea 브랜치도 로컬 브랜치로 바꿀 수 있다. 이렇게 명령어를 입력하면 `git branch`를 했을때 정상적으로 브랜치들을 출력하는것을 확인할 수 있다. 다음과 같이 말이다.

![clone_2](https://user-images.githubusercontent.com/76525173/117458535-5b2b2f00-af85-11eb-81db-f7c31cf4ddf4.jpg)

--decorate를 통해서도 그래프를 출력했을 때, 원격 저장소에서 pull한것처럼 그래프를 출력하는것을 알 수 있다. 다음과 같이 말이다.

![clone_3](https://user-images.githubusercontent.com/76525173/117459168-118f1400-af86-11eb-97b9-2596ecf82e9e.jpg)

맨 밑에 main 브랜치가 있을 것이다. 이 브랜치는 repository를 처음 생성하며 만들어지는 브랜치이기 때문에 자동으로 불러와지는 것이다. 위 사진을 봤을 때 기존 환경과 똑같이 git 저장소가 만들어졌다는것을 알 수 있다.

정리하자면 `git clone`은 빈 폴더에 원격 저장소로부터 모든 내역들을 내려받아서 git 환경으로 만들어주는 명령어라고 할 수 있다. 아무것도 없고 `git init`만 된 폴더에 pull을 한다고 해도 어느정도 맞는 말인것 같다. 자주 사용하는 옵션으로는 -b 옵션이 있을것 같다. `git clone -b 브랜치명` 이렇게 쓰는데 해당 브랜치만 복사를 하는 것이다. 학생 입장에서는 앞서 언급한 두 가지 명령어를 자주 사용할것 같다.

# 커밋에 이름을 달아보자 : tag

과제 피드백도 받고, 동료 컴퓨터에 커밋도 공유한 상태다. 그리고 최종 완성되고 교수 피드백을 받은 파일이 현재 상태로 있다. 지금 가리키고 있는 커밋은 교수 피드백까지 받은 커밋인 것이다. 나는 이 상태의 커밋을 따로 저장을 하고 싶다. 나중에 수정을 하고 커밋을 하면 브랜치들은 계속 다른 커밋들을 가리킬 것이다. 그거와는 별개로 지금 가리키고 있는 커밋에 이름을 딱 정해서 나중에 언제든지 그 이름을 통해 커밋을 찾아갈 수 있도록 하고 싶다. 그럴 때 이용하는 명령어가 `git tag`이다.

`git tag`는 커밋에 고유한 이름을 다는 명령어이다. 이름을 정함으로서 나중에 쉽게 해당 커밋으로 접근할 수 있다. 사용법은 다음과 같다.

    git tag 1.0.0

이 명령어는 현재 checkout된 브랜치가 가리키고 있는 커밋에 "1.0.0"이라는 이름의 태그를 다는 것이다. 꼭 현재 브랜치가 가리키는 커밋이 아니더라도 해당 커밋의 일련번호를 이용해서 태그를 달 수 있다. 다음과 같이 말이다.

    git tag 6a2be 1.0.0

다음 명령어는 일련번호가 6a2be인 커밋에 1.0.0이라는 이름의 태그를 붙이는 것이다. 이렇게 명령어를 입력하고 log를 이용해서 로그를 보면 다음과 같은 변화가 일어났을 것이다.

![tag_1](https://user-images.githubusercontent.com/76525173/117470726-16f25b80-af92-11eb-9f8d-f460c0d508bb.jpg)

태그를 단 커밋에 tag: 1.0.0 내용이 추가되었음을 알 수 있다. 이는 정상적으로 태그가 추가된 것이다. 이렇게 태그를 설정했으면 앞서 언급한대로 브랜치가 어떤 것을 가리키든 이 태그는 해당 커밋에 계속 붙어있을 것이다. 또한 `git tag`만을 입력하면 태그 이름들을 출력할 것이다. 어떤 태그들이 만들어졌는지 보고 싶으면 이 명령어를 이용하면 될 것이다. 또한 해당 태그로 체크아웃을 해서 해당 태그가 가리키고 있는 커밋인 상태로 돌아갈 수 있다. 다음과 같은 명령어를 이용하면 된다.

    git checkout 1.0.0

이 명령어는 태그 이름이 1.0.0인 커밋으로 체크아웃을 하는 명령어이다.

또한 이 태그를 로컬 저장소 안에서만 사용하는것은 섭섭하다. 원격 저장소에도 올려주는것이 미래를 위해서 좋을 것이다. 태그는 이전에 언급한대로 push를 하면 태그가 올라가지 않는다. 태그만을 push하는 명령어가 따로 존재한다. 그것은 다음과 같다.

    git push --tag

그러면 태그만이 원격 저장소에 push 될 것이다. 그리고 원격 저장소를 가면 다음과 같은 변화가 일어났음을 알 수 있다.

![tag_2](https://user-images.githubusercontent.com/76525173/117471829-376ee580-af93-11eb-9e89-3f7825070f4e.jpg)

tag칸에 1이 추가되었음을 알 수 있다. 여기를 들어가보면 1.0.0 태그가 정상적으로 업로드되었음을 알 수 있다. 다음과 같이 말이다.

![tag_3](https://user-images.githubusercontent.com/76525173/117471876-435aa780-af93-11eb-8edd-85c073109c31.jpg)

나중에 이 태그가 필요한 상황이 올 때 간편하게 그 상황으로 돌아갈 수 있을 것이다.

`git tag`에 관해서 정리하자면 이 명령어는 해당 커밋에 이름을 다는 것이다. 로컬 저장소에서는 이름만 다는 것에서 끝날 수 있지만 원격 저장소로 push를 하게 되면 태그들만 따로 관리되는 항목이 따로 있는데, 이 항목을 통해서 태그들이 가리키는 커밋들을 다운로드 받거나 다룰 수 있다. 보통 tag는 개발을 하면서 각 버전이 계속 업데이트가 될텐데, 그 버전을 저장하는 용도로 많이 사용한다. 각 버전들을 "1.0.0"같은 태그 이름으로 관리를 하고 그것을 원격 저장소에 push를 한다. 그렇게 되면 업데이트 현황을 한 눈에 파악할 수 있고 필요할 때 이전 버전으로 돌아가기 간편해지고, 사용자 입장에서도 그 버전 파일을 다운로드 받아서 사용할 수 있다. tag를 잘 쓰면 이렇게 용이하게 쓸 수 있다.

또 사용할 것 같은 옵션으로는 -a, -m 옵션이 있다. 이 옵션은 annotated 태그에 관한 옵션이다. 지금 우리가 다룬 tag는 lightweight tag, 즉 가벼운 태그이다. 이 태그는 간단한 정보만 담을 수 있다. 그에 반해서 많은 정보들을 담을 수 있는 태그도 있다. annotated tag라고도 하는데 이 태그를 이용하면 여러 정보들을 담을 수 있다. `git tag -a 1.0.0 -m "태그에 관한 설명"` 이런 식으로 사용을 할 수 있고, `git tag -v 1.0.0`을 통해서 그 자세한 정보를 확인할 수 있다. 학생 입장에서는 이런 annotated 태그 보다는 주로 lightweight 태그를 많이 사용할 것 같다.

| 명령어                                                   |                                                             |                                                                            |                                                        |
| -------------------------------------------------------- | ----------------------------------------------------------- | -------------------------------------------------------------------------- | ------------------------------------------------------ |
| [config](#git-설정하기--config)                         | [init](#git-시작하기--init)                                | [add](#Staging-area로-보내기--git-add)                                    | [status](#파일의-현재-상태-확인하기--status)          |
| [commit](#Git-directory로-올리기--git-commit)           | [log](#커밋-로그-확인하기--git-log)                        | [reset](#파일을-이전-상태로-되돌리기--git-reset---hard)                   | [branch](#또-다른-작업-환경-만들기--branch-checkout) |
| [checkout](#또-다른-작업-환경-만들기--branch-checkout) | [merge](#병합하기--merge)                                  | [rebase](#베이스를-다시-설정하자--rebase)                                 | [remote](#원격-저장소를-추가하자--remote)             |
| [push](#내가-만든-파일을-github에-올려보자--push)       | [pull](#원격-저장소에서-로컬-저장소로-파일-불러오기--pull) | [clone](#다른-폴더-다른-기기에서도-원격-저장소-내용들을-불러오자--clone) | [tag](#커밋에-이름을-달아보자--tag)                   |
